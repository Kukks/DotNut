using System.Diagnostics;
using DotNut.Abstractions.Interfaces;
using DotNut.Abstractions.Quotes;
using DotNut.Api;
using DotNut.ApiModels;
using DotNut.ApiModels.Mint.bolt12;
using DotNut.NBitcoin.BIP39;
using DotNut.NUT13;

namespace DotNut.Abstractions;

// It should: 
// Allow user to use local keys from db 

// Fetch keyets on start, if user didn't provide them. Fetch additional Keys. (if necessary)

// How can user save these? 
// ARE FLUENT BUILDER \

/// <summary>
/// Main Cashu Wallet class implementing fluent builder pattern
/// </summary>
public class Wallet : ICashuWalletBuilder
{
    private MintInfo? _info;
    private IProofSelector? _selector;
    private ICashuApi? _mintApi;
    private List<GetKeysetsResponse.KeysetItemResponse>? _keysets;
    private List<GetKeysResponse.KeysetItemResponse>? _keys;
    private Dictionary<KeysetId, ulong>? _keysetFees => _keysets?.ToDictionary(k=>k.Id, k=>k.InputFee??0);

    private Mnemonic? _mnemonic;
    private ICounter? _counter;
    
    //flags 
    private bool _shouldSyncKeyset = true;
    private bool _shouldBumpCounter = true;
    private bool _allowInvalidKeysetIds = false;

    public static ICashuWalletBuilder Create() => new Wallet();
    
    /// <summary>
    /// Mandatory. Sets a mint in a wallet object
    /// </summary>
    /// <param name="mintApi">Mint API object.</param>
    public ICashuWalletBuilder WithMint(ICashuApi mintApi)
    {
        _mintApi = mintApi;
        return this;
    }
    
    /// <summary>
    /// Mandatory. Sets a mint in a wallet object (with default CashuHttpClient)
    /// </summary>
    /// <param name="mintApi">Mint URL string.</param>
    public ICashuWalletBuilder WithMint(string mintUrl)
    {
        var httpClient = new HttpClient{ BaseAddress = new Uri(mintUrl)};
        _mintApi = new CashuHttpClient(httpClient);
        return this;
    }
    
    /// <summary>
    /// Optional. Import Mint Info to CashuWallet. Otherwise, it will be fetched from /v1/info endpoint.
    /// </summary>
    /// <param name="info"> MintInfo object</param>
    public ICashuWalletBuilder WithInfo(MintInfo info)
    {
        this._info = info;
        return this;
    }
    
    /// <summary>
    /// Optional. Import Mint Info to CashuWallet. Otherwise, it will be fetched from /v1/info endpoint.
    /// </summary>
    /// <param name="info">GetInfoResponse payload returned from mints API</param>
    public ICashuWalletBuilder WithInfo(GetInfoResponse info) => this.WithInfo(new MintInfo(info));
    
    /// <summary>
    /// Optional. Import Keysets into CashuWallet class. Otherwise, they will be fetched from /v1/keysets endpoint.
    /// </summary>
    /// <param name="keysets">List of Keysets</param>
    public ICashuWalletBuilder WithKeysets(IEnumerable<GetKeysetsResponse.KeysetItemResponse> keysets)
    {
        this._keysets = keysets.ToList();
        return this;
    }
    
    /// <summary>
    /// Optional. Import Keysets into CashuWallet class. Otherwise, they will be fetched from /v1/keysets endpoint.
    /// </summary>
    /// <param name="keysets">GetKeysetsResponse payload returned from mints API</param>
    public ICashuWalletBuilder WithKeysets(GetKeysetsResponse keysets) => this.WithKeysets(keysets.Keysets.ToList());
    
    /// <summary>
    /// Optional. Import Keys into CashuWallet class. Otherwise, they will be fetched from /v1/keys endpoint.
    /// </summary>
    /// <param name="keysets">List of mints Keys</param>
    public ICashuWalletBuilder WithKeys(IEnumerable<GetKeysResponse.KeysetItemResponse> keys)
    {
        this._keys = keys.ToList();
        return this;
    }

    /// <summary>
    /// Optional. Import Keys into CashuWallet class. Otherwise, they will be fetched from /v1/keys endpoint.
    /// </summary>
    /// <param name="keysets">GetKeysResponse payload returned from mints API</param>
    public ICashuWalletBuilder WithKeys(GetKeysResponse keys) => this.WithKeys(keys.Keysets.ToList());
    
    /// <summary>
    /// Optional. Flag suggesting if CashuWallet should sync provided Keys and Keysets with actual mints state.
    /// Very useful if wallet stores keys in storage.
    /// </summary>
    /// <param name="syncKeyset">boolean, true by default</param>
    public ICashuWalletBuilder WithKeysetSync(bool syncKeyset = true)
    {
        this._shouldSyncKeyset = syncKeyset;
        return this;
    }
    
    /// <summary>
    /// Optional. Proof selecting algorithm. If not set, defaults to RGLI proof selector.
    /// </summary>
    /// <param name="selector"></param>
    public ICashuWalletBuilder WithSelector(IProofSelector selector)
    {
        _selector = selector;
        return this;
    }
    
    /// <summary>
    /// Optional. BIP39 seed for secret and blinding factors derivation. All proofs generated by CashuWallet will be recoverable.
    /// </summary>
    /// <param name="mnemonic">Mnemonic object</param>
    public ICashuWalletBuilder WithMnemonic(Mnemonic mnemonic)
    {
        _mnemonic = mnemonic;
        return this;
    }
    
    /// <summary>
    /// Optional. BIP39 seed for secret and blinding factors derivation. All proofs generated by CashuWallet will be recoverable.
    /// </summary>
    /// <param name="mnemonic">Bip39 seed string separated by spaces.</param>
    public ICashuWalletBuilder WithMnemonic(string mnemonic)
    {
        _mnemonic = new Mnemonic(mnemonic);
        return this;
    }
    

    /// <summary>
    /// Optional and mandatory if Mnemonic provided. Counter for each Keyset Id for derivation purposes.
    /// </summary>
    /// <param name="counter">Counter object</param>
    public ICashuWalletBuilder WithCounter(ICounter counter)
    {
        this._counter = counter;
        return this;
    }

    /// <summary>
    /// Optional and mandatory if Mnemonic provided. Counter for each Keyset Id for derivation purposes.
    /// </summary>
    /// <param name="counter">Counter dictionary</param>
    /// <returns></returns>
    public ICashuWalletBuilder WithCounter(IDictionary<KeysetId, int> counter)
    {
        this._counter = new Counter(counter);
        return this;
    }

    /// <summary>
    /// Optional and if not set, always true. Controls automatic counter incrementation for secret generation.
    /// </summary>
    /// <param name="shouldBumpCounter">If true, counter increments automatically. If false, requires manual management.</param>
    /// <remarks>
    /// WARNING: Disabling auto-increment is potentially dangerous. Manual counter management is required 
    /// to prevent secret reuse, which will cause mint rejection and operation failures.
    /// </remarks>
    public ICashuWalletBuilder ShouldBumpCounter(bool shouldBumpCounter = true)
    {
        this._shouldBumpCounter = shouldBumpCounter;
        return this;
    }
    
    /// <summary>
    /// Create swap transaction builder.
    /// </summary>
    /// <returns>Swap transaction builder</returns>
    public ICashuWalletSwapBuilder Swap()
    {
        return new CashuWalletSwapBuilder(this);
    }

    public ICashuWalletMeltQuoteBuilder CreateMeltQuote()
    {
        return new CashuWalletMeltQuoteBuilder(this);
    }

    public ICashuWalletMintBuilder CreateMintQuote()
    {
        return new CashuWalletMintQuoteBuilder(this);
    }
    
    public ICashuWalletRestoreBuilder Restore()
    {
        return new CashuWalletRestoreBuilder(this);
    }
    
    /// <summary>
    /// Wrapper for GetKeysets api endpoint. Formats Keysets to list.
    /// </summary>
    /// <returns>List of Keysets</returns>
    /// <exception cref="ArgumentNullException">May be thrown if mint is not set.</exception>
    private async Task<List<GetKeysetsResponse.KeysetItemResponse>> _fetchKeysets(CancellationToken cts = default)
    {
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(this._mintApi), "Can't fetch mint info without mintApi");
        }
        var keysetsRaw = await _mintApi!.GetKeysets(cts);
        return keysetsRaw.Keysets.ToList();
    }
    
    /// <summary>
    /// Wrapper for GetKeys api endpoint. Validates returned KeysetIds and formats Keys to list.
    /// </summary>
    /// <returns>List of Keys (lists :))</returns>
    /// <exception cref="ArgumentNullException">May be thrown if mint is not set.</exception>
    /// <exception cref="ArgumentException">May be thrown if mint returns invalid keysetId for at least one Keyset</exception>
    private async Task<List<GetKeysResponse.KeysetItemResponse>> _fetchKeys(CancellationToken cts = default)
    {
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(_mintApi), "Can't fetch mint info without mintApi");
        }
        var keysRaw = await _mintApi!.GetKeys(cts);
        foreach (var keysetItemResponse in keysRaw.Keysets)
        {
            var isKeysetIdValid = keysetItemResponse.Keys.VerifyKeysetId(keysetItemResponse.Id, keysetItemResponse.Unit, keysetItemResponse.FinalExpiry);
            if (!isKeysetIdValid)
            {
                throw new ArgumentException($"Mint provided invalid keysetId. Provided: {keysetItemResponse.Id}, derived: {keysetItemResponse.Keys.GetKeysetId()} ");
            }
        }
        return keysRaw.Keysets.ToList();
    }
    
    /// <summary>
    /// Wrapper for GetKeys api endpoint. Validates KeysetId and fetches keys for single KeysetId Formats Keys to list. 
    /// </summary>
    /// <param name="id">KeysetId we want fetch keys for.</param>
    /// <returns>Keys</returns>
    /// <exception cref="ArgumentException">May be thrown if mint returns invalid keysetId for at least one Keyset</exception>
    /// <exception cref="ArgumentNullException">May be thrown if mint is not set.</exception>
    private async Task<GetKeysResponse.KeysetItemResponse> _fetchKeys(KeysetId id, CancellationToken cts = default)
    {
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(_mintApi), "Can't fetch mint info without mintApi");
        }
        var keysRaw = (await _mintApi!.GetKeys(id, cts)).Keysets.Single();
        
        var isKeysetIdValid = keysRaw.Keys.VerifyKeysetId(keysRaw.Id, keysRaw.Unit, keysRaw.FinalExpiry);
        if (!isKeysetIdValid)
        {
            throw new ArgumentException($"Mint provided invalid keysetId. Provided: {keysRaw.Id}, derived: {keysRaw.Keys.GetKeysetId()} ");
        }

        return keysRaw;
    }
    
    /// <summary>
    /// Wrapper for GetInfo api endpoint. Translates Payload to MintInfo.
    /// </summary>
    /// <exception cref="ArgumentNullException">May be thrown if mint is not set.</exception>
    private async Task<MintInfo> _fetchMintInfo(CancellationToken cts = default)
    {
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(this._mintApi), "Can't fetch mint info without mintApi");
        }

        var infoRaw = await _mintApi!.GetInfo(cts);
        return new MintInfo(infoRaw);
    }

    /// <summary>
    /// Fetches mint info if not present in CashuWallet.
    /// </summary>
    /// <exception cref="ArgumentNullException"></exception>
    private async Task<MintInfo> _lazyFetchMintInfo(CancellationToken cts = default)
    {
        if (this._info != null) return this._info;
        if (_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(this._mintApi), "Can't fetch mint info without mintApi");
        }
        return await this._fetchMintInfo(cts);
    }
    
    /// <summary>
    /// Local Keys sync. 
    /// </summary>
    /// <param name="cts"></param>
    /// <exception cref="ArgumentNullException"></exception>
    internal async Task _maybeSyncKeys(CancellationToken cts = default)
    {
        if (!_shouldSyncKeyset)
        {
            return;
        }
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(this._mintApi), "Can't sync mint keys without mintApi");
        }
        
        this._keysets = await _fetchKeysets(cts);
        if (_keys == null)
        {
            this._keys = await _fetchKeys(cts); // we're fetching all keys here, so no need for additional check.
            return;
        }
        
        var knownIds = _keys.Select(key => key.Id).ToHashSet();
        var unknownKeysets = _keysets.Where(k => !knownIds.Contains(k.Id)).ToList();

        if (unknownKeysets.Count > 2) // just make a single request. May override stored keys.
        {
            this._keys = await _fetchKeys(cts);
            return;
        }
        
        foreach (var unknownKeyset in unknownKeysets)
        {
            var keyset = await this._fetchKeys(unknownKeyset.Id, cts); 
            this._keys.Add(keyset);
        }
    }
    public async Task<KeysetId?> GetActiveKeysetId(string unit, CancellationToken cts = default)
    {
        return _keysets?
            .OrderBy(k => k.InputFee)
            .FirstOrDefault(k => k.Active == true && k.Unit == unit, null)
            ?.Id;
    }

    public async Task<IDictionary<string, KeysetId>?> GetActiveKeysetIdsWithUnits()
    {
        return _keysets?
            .GroupBy(k => k.Unit)
            .ToDictionary(
                g => g.Key,
                g => g.OrderBy(k => k.InputFee).First().Id
            );
    }
    public async Task<List<GetKeysResponse.KeysetItemResponse>> GetKeys(bool forceRefresh = false, CancellationToken cts = default)
    {
        if (forceRefresh)
        {
           this._keys =  await _fetchKeys(cts);
        }
        return this._keys ?? [];
    }

    public async Task<GetKeysResponse.KeysetItemResponse> GetKeys(KeysetId id, bool forceRefresh = false, CancellationToken cts = default)
    {
        if (forceRefresh)
        {
            return await _fetchKeys(id, cts);
        }
        if (this._keys == null)
        {
            throw new ArgumentNullException(nameof(this._keys), "Wallet doesn't contain keys for this keyset!");
        }
        return this._keys.Single(k => k.Id == id);
    }
    public async Task<List<GetKeysetsResponse.KeysetItemResponse>> GetKeysets(bool forceRefresh = false, CancellationToken cts = default)
    {
        if (forceRefresh)
        {
           this._keysets = await _fetchKeysets(cts);
        }
        
        return _keysets ?? [];
    }
    public async Task<MintInfo> GetInfo(bool forceReferesh = false, CancellationToken cts = default)
    {
        if (forceReferesh)
        {
            return await _fetchMintInfo(cts);
        }
        return await _lazyFetchMintInfo(cts);
    }
    public async Task<OutputData> CreateOutputs(List<ulong> amounts, KeysetId id, CancellationToken cts = default)
    {
        if (this._keys == null)
        {
            throw new ArgumentNullException(nameof(this._keys), "No Keys found. Make sure to fetch them!");
        }
        var keyset = this._keys.Single(k => k.Id == id);
        if (this._mnemonic == null)
        {
            return CashuUtils.CreateOutputs(amounts, id, keyset.Keys);
        }

        if (this._counter == null)
        {
            throw new ArgumentNullException(nameof(ICounter), "Can't derive outputs without keyset counter");
        }

        var counterValue = await this._counter.GetCounterForId(id);
        if (_shouldBumpCounter)
        {
            await this._counter.IncrementCounter(id, amounts.Count);
        }
        return CashuUtils.CreateOutputs(amounts, id, keyset.Keys, this._mnemonic, counterValue);
    }
    
    internal async Task<PostSwapResponse> _swap(PostSwapRequest request, CancellationToken cts = default)
    {
        if (!_ensureApiConnected())
        {
            throw new ArgumentNullException(nameof(this._mintApi), "Can't swap without mintApi");
        }

        return await this._mintApi!.Swap(request, cts);
    }
    
    public IProofSelector? GetSelector() => _selector;
    public ICashuApi? GetMintApi() => _mintApi;
    public Mnemonic? GetMnemonic() => _mnemonic;
    public ICounter? GetCounter() => _counter;
    private bool _ensureApiConnected() => _mintApi != null;
}

class CashuWalletMintQuoteBuilder : ICashuWalletMintBuilder
{
    private readonly Wallet _wallet;
    private ulong? _amount;
    private string _unit = "sat";
    private string? _description;
    private OutputData? _outputs;
    private string? _method = "bolt11"; 
    
    //for bolt12
    private string? _pubkey;

    private KeysetId? _keysetId;
    private GetKeysResponse.KeysetItemResponse keyset;
    public CashuWalletMeltQuoteBuilder(Wallet wallet)
    {
        this._wallet = wallet;
    }

    /// <summary>
    /// Mandatory.
    /// User has to provide Mint method
    /// </summary>
    /// <param name="method">Either MintMeltMethod.Bolt11 or MintMeltMethod.Bolt12</param>
    /// <returns></returns>
    public ICashuWalletMintBuilder WithMethod(string method)
    {
        this._method = method;
        return this;
    }
    
    /// <summary>
    /// Mandatory.
    /// </summary>
    /// <param name="amount">Amount of token in currently choosen unit to be melted</param>
    public ICashuWalletMintBuilder WithAmount(ulong amount)
    {
        this._amount = amount;
        return this;
    }
    
    /// <summary>
    /// Optional.
    /// Sets unit of tokens being minted. Sat by default.
    /// </summary>
    /// <param name="unit">Unit of minted proofs</param>
    public ICashuWalletMintBuilder WithUnit(string unit)
    {
        this._unit = unit;
        return this;
    }

    /// <summary>
    /// Optional. Necessary for bolt12
    /// Sets pubkey for bolt12 offer 
    /// </summary>
    /// <param name="pubkey"></param>
    /// <returns></returns>
    public ICashuWalletMintBuilder WithPubkey(string pubkey)
    {
        this._pubkey = pubkey;
        return this;
    }
    
    /// <summary>
    /// Optional.
    /// Allows user to set keysetId manually. Otherwise, builder will choose active one manually, with the lowest fees.
    /// </summary>
    /// <param name="keysetId"></param>
    public ICashuWalletMintBuilder WithKeyset(KeysetId keysetId)
    {
        this._keysetId = keysetId;
        return this;
    }
    

    /// <summary>
    /// Optional.
    /// User may provide outputs for mint to sign. Blinding factors and secrets won't be revealed to mint.
    /// If not provided, wallet will try to derive them from seed and counter, or create random ones if mnemonic is not avaible.
    /// </summary>
    /// <param name="outputs">OutputData instance. Enumerables of BlindingFactors, BlindedMessages and Secrets, in right order.</param>
    public ICashuWalletMintBuilder WithOutputs(OutputData outputs)
    {
        this._outputs = outputs;
        return this;
    }
    
    /// <summary>
    /// Optional.
    /// User may provide description for melt quote invoice. 
    /// </summary>
    /// <param name="description"></param>
    /// <returns></returns>
    public ICashuWalletMintBuilder WithDescription(string description)
    {
        this._description = description;
        return this;
    }
    
    
    public async Task<IMintHandler> ProcessAsync(CancellationToken cts = default)
    {
        //todo implement info 

        await this._wallet._maybeSyncKeys(cts);
        if (_amount == null)
        {
            throw new ArgumentNullException(nameof(_amount), "can't create melt quote without amount!");
        }

        var api = this._wallet.GetMintApi();
        if (api is null)
        {
            throw new ArgumentNullException(nameof(ICashuApi), "Can't request mint quote without mint API");
        }

        if (this._keysetId == null)
        {
            this._keysetId = await this._wallet.GetActiveKeysetId(this._unit, cts) ??
                             throw new ArgumentException($"Can't fetch active keyset ID for unit: {_unit}");
        }
        
        switch (_method)
        {
            case "bolt11":
            {
                var reqBolt11 = new PostMintQuoteBolt11Request()
                {
                    Amount = this._amount.Value,
                    Unit = this._unit,
                    Description = this._description,
                };
                var quoteBolt11 =
                    await api.CreateMintQuote<PostMintQuoteBolt11Response, PostMintQuoteBolt11Request>("bolt11", reqBolt11,
                        cts);
                return new MintHandlerBolt11(this._wallet, quoteBolt11, this.keyset);
            }
            case "bolt12":
            {
                if (this._pubkey == null)
                {
                    throw new ArgumentNullException(nameof(_pubkey), "Can't request bolt12 mint quote without pubkey!");
                }

                var req = new PostMintQuoteBolt12Request()
                {
                    Amount = this._amount.Value,
                    Unit = this._unit,
                    Pubkey = this._pubkey,
                    Description = this._description,
                };
                var mintQuote =
                    await api.CreateMintQuote<PostMintQuoteBolt12Response, PostMintQuoteBolt12Request>("bolt12", req,
                        cts);
                return new MintHandlerBolt12(this._wallet, mintQuote, this.keyset);
            }
            default:
                throw new ArgumentException($"Unknown mint method: {_method}");
        }
    }
    
}

/// <summary>
/// Receive operation builder implementation
/// </summary>
class CashuWalletSwapBuilder : ICashuWalletSwapBuilder
{
    private readonly Wallet _wallet;
    
    // input 
    private readonly string? _tokenString;
    private readonly CashuToken? _token;
    private List<Proof>? _proofsToSwap;
    
    private OutputData? _outputs;
    private List<ulong>? _amounts;
    private KeysetId? _keysetId;
    private string? _unit;
    private bool _verifySignatures = true;

    public CashuWalletSwapBuilder(Wallet wallet, string tokenString)
    {
        _wallet = wallet;
        _tokenString = tokenString;
    }
    public CashuWalletSwapBuilder(Wallet wallet, CashuToken token)
    {
        _wallet = wallet;
        _token = token;
    }
    public CashuWalletSwapBuilder(Wallet wallet)
    {
        _wallet = wallet;
    }
    
    /// <summary>
    /// Optional. Base unit of wallet instance. If not set defaults to "SAT".
    /// </summary>
    /// <param name="unit"></param>
    public ICashuWalletSwapBuilder WithUnit(string unit)
    {
        this._unit = unit;
        return this;
    }
    
    public ICashuWalletSwapBuilder WithSignatureVerification(bool verify = true)
    {
        _verifySignatures = verify;
        return this;
    }
    public ICashuWalletSwapBuilder WithOutputs(OutputData outputs)
    {
        _outputs = outputs;
        return this;
    }
    public ICashuWalletSwapBuilder WithAmounts(IEnumerable<ulong> amounts)
    {
        _amounts = amounts.ToList();
        return this;
    }
    public ICashuWalletSwapBuilder ForKeyset(KeysetId keysetId)
    {
        _keysetId = keysetId;
        return this;
    }
    private async Task<List<Proof>> _getSwapProofs()
    {
        _proofsToSwap ??= new();
        if (_tokenString != null)
        {
            var token = CashuTokenHelper.Decode(this._tokenString, out var v);
            if (v == "A") // todo ensure 
            {
                //if token is v1, ensure everything is from the same mint 
                var mints = token.Tokens.Select(t => t.Mint).ToList();
                if (mints.Count > 1)
                {
                    throw new ArgumentException("Only swap from single mint is allowed");
                }
                
            }
            this._proofsToSwap.AddRange(token.Tokens.SelectMany(t=>t.Proofs));
        }

        if (_token == null) return _proofsToSwap;
        
        //if token is v1, ensure everything is from the same mint 
        var tokenMints = _token.Tokens.Select(t => t.Mint).ToList();
        if (tokenMints.Count > 1)
        {
            throw new ArgumentException("Only swap from single mint is allowed");
        }
        this._proofsToSwap.AddRange(_token.Tokens.SelectMany(t=>t.Proofs));
        
        return _proofsToSwap;
    }
    public async Task<List<Proof>> ProcessAsync(CancellationToken cts = default)
    {
        if (_wallet.GetMintApi() == null)
            throw new InvalidOperationException("Mint API must be configured");
        
        await _getSwapProofs();
        if (_proofsToSwap == null || _proofsToSwap.Count == 0)
        {
            throw new ArgumentException("Nothing to swap!");
        }
        
        // if there's no keysetId specified - let's choose it. 
        if (_keysetId == null)
        {
            _keysetId = await _wallet.GetActiveKeysetId(this._unit, cts) ??
                        throw new InvalidOperationException("Could not fetch Keyset ID");
        }
        var keys = await _wallet.GetKeys(false, cts);
        var keysForCurrentId = keys.Single(k=>k.Id == _keysetId);
        
        if (_verifySignatures)
        {
            foreach (var proof in _proofsToSwap!)
            {
               var keyset = keys.Single(k => k.Id == proof.Id);
               if (keyset.Keys.TryGetValue(proof.Amount, out var key))
               {
                   throw new InvalidOperationException($"Can't find key for amount {proof.Amount} in keyset ${keyset.Id}");
               }
               var isValid = proof.Verify(key);
            if (!isValid)
                throw new InvalidOperationException($"Invalid proof signature for amount {proof.Amount}");
            }
        }
        
        ulong total = _proofsToSwap!.Aggregate<Proof, ulong>(0, (acc, p) => acc + p.Amount);
        // Swap received proofs to our keyset
        var amounts = _amounts ?? CashuUtils.SplitToProofsAmounts(total, keysForCurrentId.Keys);

        this._outputs ??= await this._wallet.CreateOutputs(amounts, _keysetId, cts);

        var request = new PostSwapRequest()
        {
            Inputs = this._proofsToSwap.ToArray(),
            Outputs = this._outputs.BlindedMessages,
        };
        
            
        var swapResponse = await _wallet.GetMintApi()!.Swap(request, cts);

        var swappedProofs =
            CashuUtils.ConstructProofsFromPromises(swapResponse.Signatures.ToList(), this._outputs, keysForCurrentId.Keys);

        return swappedProofs;
    }
}

class CashuWalletMeltQuoteBuilder : ICashuWalletMeltQuoteBuilder
{
    private readonly Wallet _wallet;
    private List<Proof>? _proofs;
    private string? _invoice;
    private OutputData? _blankOutputs;
    private ulong? _amount;
    private string? _method;
    
    public CashuWalletMeltQuoteBuilder(Wallet wallet)
    {
        _wallet = wallet;
    }
    
    public ICashuWalletMeltQuoteBuilder WithInvoice(string invoice)
    {
        this._invoice = invoice;
        return this;
    }

    public ICashuWalletMeltQuoteBuilder WithMethod(string method = "bolt11")
    {
        throw new NotImplementedException();
    }

    public Task<MeltResult> ProcessAsync(CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public ICashuWalletMeltQuoteBuilder WithProofs(IEnumerable<Proof> proofs)
    {
        this._proofs = proofs.ToList();
        return this;
    }

    public ICashuWalletMeltQuoteBuilder WithBlankOutputs(OutputData blankOutputs)
    {
        this._blankOutputs = blankOutputs;
        return this;
    }

    public ICashuWalletMeltQuoteBuilder WithAmount(ulong amount)
    {
        this._amount = amount;
        return this;
    }

    public async Task<MeltQuoteBolt11> ProcessAsyncBolt11(CancellationToken cancellationToken = default)
    {
        var activeKeysetId = _wallet.GetActiveKeysetId()??
                             throw new InvalidOperationException("Could not fetch active Keyset ID");
        var activeKeyset = _wallet.GetKeysets().SingleOrDefault(k => k.Id == activeKeysetId, null)??
                           throw new InvalidOperationException($"Could not fetch keyset for KeysetId: {activeKeysetId}");
        var mnemonic = _wallet.GetMnemonic();
        var counter = _wallet.GetCounter();
        
        if (_blankOutputs == null)
        {
            if (_amount != null)
            {
                _blankOutputs = CashuUtils.CreateBlankOutputs(_amount, activeKeysetId, activeKeyset.Keys, mnemonic, counter?.GetCounterForId(activeKeysetId));
            }
            // processing without blank outputs
        }        
        var req = new PostMeltQuoteBolt11Request
        {
            Request = this._invoice,
            Unit = _wallet.GetUnit()
        };
        var mintResponse = await _wallet.GetMintApi().CreateMeltQuote<PostMeltQuoteBolt11Response, PostMeltQuoteBolt11Request>("bolt11", req, cancellationToken);
        
        return new MeltQuoteBolt11(mintResponse);
    }
}

class CashuWalletRestoreBuilder : ICashuWalletRestoreBuilder
{
    private readonly Wallet _wallet;
    private List<KeysetId>? _specifiedKeysets;

    private bool _shouldSwap = true;

    public CashuWalletRestoreBuilder(Wallet wallet)
    {
        this._wallet = wallet;
    }
    
    public ICashuWalletRestoreBuilder ForKeysetIds(IEnumerable<KeysetId> keysetIds)
    {
        this._specifiedKeysets = keysetIds.ToList();
        return this;
    }

    public ICashuWalletRestoreBuilder WithSwap(bool shouldSwap = true)
    {
        this._shouldSwap = shouldSwap;
    }

    public async Task<List<Proof>> ProcessAsync(CancellationToken cts = default)
    {
        var mnemonic = _wallet.GetMnemonic()??
                       throw new ArgumentNullException("Can't restore wallet without Mnemonic");
        if (_specifiedKeysets == null)
        {
            _specifiedKeysets = (await _wallet.GetKeysets()).Select(k=>k.Id).ToList();
        }
        var api = _wallet.GetMintApi();
        if (api == null)
        {
            throw new ArgumentNullException(nameof(api), "Can't restore wallet without MintApi");
        }
        
        var counter = _wallet.GetCounter();
        if (counter == null)
        {
            _wallet.WithCounter(new Counter(new Dictionary<KeysetId, int>()));
        }

        List<Proof> recoveredProofs = new List<Proof>();
        foreach (var keysetId in _specifiedKeysets)
        {
            bool isKeysetRestored = false;
            int batchNumber = 0;
            int emptyBatchesRemaining = 3;

            var keyset = await _wallet.GetKeys(keysetId, false, cts);
            
            while (!isKeysetRestored && emptyBatchesRemaining > 0)
            {
                var outputs = await _createBatch(mnemonic, keysetId, batchNumber, cts);
                await counter!.IncrementCounter(keysetId, batchNumber * 100);
                var req = new PostRestoreRequest
                {
                    Outputs = outputs.BlindedMessages
                };
                var res = await api.Restore(req, cts);

                if (!res.Signatures.Any())
                {
                    emptyBatchesRemaining--;
                }

                var proofs = CashuUtils.ConstructProofsFromPromises(res.Signatures.ToList(), outputs, keyset.Keys);
                recoveredProofs.AddRange(proofs);
            }
            
        }
        
        if (!this._shouldSwap || !recoveredProofs.Any())
        {
            return recoveredProofs;
        }
        
        var freshProofs = new List<Proof>();
        var activeUnits = await this._wallet.GetActiveKeysetIdsWithUnits();
        if (activeUnits != null && !activeUnits.Any())
        {
            throw new InvalidOperationException("Could not restore wallet without active keysets");
        }

        foreach (var unitKeyset in activeUnits)
        {
            var correspondingKeys = await _wallet.GetKeys(unitKeyset.Value, false, cts);
            var totalAmount = recoveredProofs.Select(p=>p.Amount).Aggregate((a,c) => a + c);
            var amounts = CashuUtils.SplitToProofsAmounts(totalAmount, correspondingKeys.Keys);
            var ctr = await counter!.GetCounterForId(unitKeyset.Value, cts);
            var newOutputs = CashuUtils.CreateOutputs(amounts, unitKeyset.Value, correspondingKeys.Keys, mnemonic, ctr);
            await counter.IncrementCounter(unitKeyset.Value, newOutputs.BlindedMessages.Length, cts);
            
            var swapRequest = new PostSwapRequest
            {
                Inputs = recoveredProofs.ToArray(),
                Outputs = newOutputs.BlindedMessages,
            };
        
            var swapResult = await _wallet._swap(swapRequest, cts);
            
            var constructedProofs = CashuUtils.ConstructProofsFromPromises(swapResult.Signatures.ToList(), newOutputs, correspondingKeys.Keys);
            
            freshProofs.AddRange(constructedProofs);
        }
        return freshProofs;
    }

    private async Task<OutputData> _createBatch(Mnemonic mnemonic, KeysetId keysetId, int batchNubmber, CancellationToken cts)
    {
        var amounts = Enumerable.Repeat((ulong)1, 100).ToList();
        return mnemonic.DeriveOutputs(amounts, keysetId, batchNubmber*100);
    }
}
