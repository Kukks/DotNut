using DotNut.Abstractions.Interfaces;
using DotNut.Abstractions.Websockets;
using DotNut.Api;
using DotNut.ApiModels;
using DotNut.ApiModels.Mint.bolt12;
using DotNut.NBitcoin.BIP39;

namespace DotNut.Abstractions;

/// <summary>
/// Fluent builder interface for Cashu Wallet operations
/// </summary>
public interface IWalletBuilder
{
    /// <summary>
    /// Mandatory. Sets a mint in a wallet object
    /// </summary>
    /// <param name="mintApi">Mint API object.</param>
    IWalletBuilder WithMint(ICashuApi mintApi);
    
    /// <summary>
    /// Mandatory. Sets a mint in a wallet object (with default CashuHttpClient)
    /// </summary>
    /// <param name="mintApi">Mint URL string.</param>
    IWalletBuilder WithMint(string mintUrl);
    
    /// <summary>
    /// Optional. Import Mint Info to CashuWallet. Otherwise, it will be fetched from /v1/info endpoint.
    /// </summary>
    /// <param name="info"> MintInfo object</param>
    IWalletBuilder WithInfo(MintInfo info);
    
    /// <summary>
    /// Optional. Import Mint Info to CashuWallet. Otherwise, it will be fetched from /v1/info endpoint.
    /// </summary>
    /// <param name="info">GetInfoResponse payload returned from mints API</param>
    IWalletBuilder WithInfo(GetInfoResponse info);
    
    /// <summary>
    /// Optional. Import Keysets into CashuWallet class. Otherwise, they will be fetched from /v1/keysets endpoint.
    /// </summary>
    /// <param name="keysets">List of Keysets</param>
    IWalletBuilder WithKeysets(IEnumerable<GetKeysetsResponse.KeysetItemResponse> keysets);
    
    /// <summary>
    /// Optional. Import Keysets into CashuWallet class. Otherwise, they will be fetched from /v1/keysets endpoint.
    /// </summary>
    /// <param name="keysets">GetKeysetsResponse payload returned from mints API</param>
    IWalletBuilder WithKeysets(GetKeysetsResponse keysets);
    
    /// <summary>
    /// Optional. Import Keys into CashuWallet class. Otherwise, they will be fetched from /v1/keys endpoint.
    /// </summary>
    /// <param name="keys">List of mints Keys</param>
    IWalletBuilder WithKeys(IEnumerable<GetKeysResponse.KeysetItemResponse> keys);
    
    /// <summary>
    /// Optional. Import Keys into CashuWallet class. Otherwise, they will be fetched from /v1/keys endpoint.
    /// </summary>
    /// <param name="keysets">GetKeysResponse payload returned from mints API</param>
    IWalletBuilder WithKeys(GetKeysResponse keys);
    
    /// <summary>
    /// Optional. Flag suggesting if CashuWallet should sync provided Keys and Keysets with actual mints state.
    /// Very useful if wallet stores keys in storage.
    /// </summary>
    /// <param name="syncKeyset">boolean, true by default</param>
    IWalletBuilder WithKeysetSync(bool syncKeyset = true);

    /// <summary>
    /// Optional. Flag suggesting if CashuWallet should sync provided Keys and Keysets with actual mints state.
    /// Has an additional field limiting how often keysets can be refetched. If not set, keysets will be synced only single time,
    /// with first operation requiring keysets. (I'd go for like, 60 minutes)
    /// </summary>
    /// <param name="syncKeyset"></param>
    /// <param name="syncThreesold"></param>
    /// <returns></returns>
    IWalletBuilder WithKeysetSync(bool syncKeyset, TimeSpan syncThreesold);
    
    /// <summary>
    /// Optional. Proof selecting algorithm. If not set, defaults to RGLI proof selector.
    /// </summary>
    /// <param name="selector"></param>
    IWalletBuilder WithSelector(IProofSelector selector);
    
    /// <summary>
    /// Optional. BIP39 seed for secret and blinding factors derivation. All proofs generated by CashuWallet will be recoverable.
    /// </summary>
    /// <param name="mnemonic">Mnemonic object</param>
    IWalletBuilder WithMnemonic(Mnemonic mnemonic); 
    
    /// <summary>
    /// Optional. BIP39 seed for secret and blinding factors derivation. All proofs generated by CashuWallet will be recoverable.
    /// </summary>
    /// <param name="mnemonic">Bip39 seed string separated by spaces.</param>
    IWalletBuilder WithMnemonic(string mnemonic);
    
    /// <summary>
    /// Optional and mandatory if Mnemonic provided. Counter for each Keyset Id for derivation purposes.
    /// </summary>
    /// <param name="counter">Counter object</param>
    IWalletBuilder WithCounter(ICounter counter);

    /// <summary>
    /// Optional and mandatory if Mnemonic provided. Counter for each Keyset Id for derivation purposes.
    /// </summary>
    /// <param name="counter">Counter dictionary</param>
    /// <returns></returns>
    public IWalletBuilder WithCounter(IDictionary<KeysetId, int> counter);
    
    /// <summary>
    /// Optional and if not set, always true. Controls automatic counter incrementation for secret generation.
    /// </summary>
    /// <param name="shouldBumpCounter">If true, counter increments automatically. If false, requires manual management.</param>
    /// <remarks>
    /// WARNING: Disabling auto-increment is potentially dangerous. Manual counter management is required 
    /// to prevent secret reuse, which will cause mint rejection and operation failures.
    /// </remarks>
    IWalletBuilder ShouldBumpCounter(bool shouldBumpCounter = true);
    
    /// <summary>
    /// Optional.
    /// Adds websocket service. You should use single websocket service (singleton at best) for multiple wallets, in order to handle everything in nice manner.
    /// If not set, but requested it'll be created automatically (which won't be so optimal).
    /// </summary>
    /// <param name="websocketService"></param>
    /// <returns></returns>
    IWalletBuilder WithWebsocketService(IWebsocketService websocketService);
    
    Task<MintInfo> GetInfo(bool forceReferesh = false, CancellationToken ct = default);
    Task<List<OutputData>> CreateOutputs(List<ulong> amounts, KeysetId id, CancellationToken ct = default);
    Task<List<OutputData>> CreateOutputs(List<ulong> amounts, string unit, CancellationToken ct = default);

    Task<IDictionary<string, KeysetId>?> GetActiveKeysetIdsWithUnits(CancellationToken ct = default);

    Task<ICashuApi> GetMintApi(CancellationToken ct = default);

    Task<KeysetId?> GetActiveKeysetId(string unit, CancellationToken ct = default);
    Task<List<GetKeysResponse.KeysetItemResponse>> GetKeys(bool forceRefresh = false, CancellationToken ct = default);

    Task<GetKeysResponse.KeysetItemResponse> GetKeys(KeysetId id, bool forceRefresh = false,
        CancellationToken ct = default);

    Task<List<GetKeysetsResponse.KeysetItemResponse>> GetKeysets(bool forceRefresh = false,
        CancellationToken ct = default);

    Task<SendResponse> SelectProofsToSend(List<Proof> proofs, ulong amount, bool includeFees,
        CancellationToken ct = default);
    
    Task<IWebsocketService> GetWebsocketService(CancellationToken ct = default);
    
    /// <summary>
    /// Create swap transaction builder.
    /// </summary>
    /// <returns>Swap transaction builder</returns>
    ISwapBuilder Swap();
    
    /// <summary>
    /// Create melt quote builder.
    /// </summary>
    /// <returns></returns>
    IMeltQuoteBuilder CreateMeltQuote();
    
    /// <summary>
    /// Create Mint Quote
    /// </summary>
    /// <returns>Method-agnostic Mint Quote builder abstraction.</returns>
    IMintQuoteBuilder CreateMintQuote();
    
    /// <summary>
    /// Can restoree proofs if mnemonic provided.
    /// </summary>
    /// <returns></returns>
    IRestoreBuilder Restore();

    /// <summary>
    /// Check state of proofs
    /// </summary>
    /// <returns></returns>
    Task<PostCheckStateResponse> CheckState(IEnumerable<Proof> proofs);

}

